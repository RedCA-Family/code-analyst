package com.samsungsds.analyst.code.node_modules.eslint;

import com.google.common.io.Files;
import com.google.common.util.concurrent.UncheckedExecutionException;
import com.google.gson.Gson;
import com.samsungsds.analyst.code.main.MeasuredResult;
import com.samsungsds.analyst.code.main.nodejs.NodeRuntime;
import com.samsungsds.analyst.code.main.nodejs.NodeRuntimeException;
import com.samsungsds.analyst.code.pmd.ComplexityAnalysis;
import com.samsungsds.analyst.code.pmd.ComplexityResult;
import com.samsungsds.analyst.code.util.FindFileUtils;
import com.samsungsds.analyst.code.util.IOAndFileUtils;
import org.apache.commons.lang3.SystemUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.sonar.api.utils.ZipUtils;

import java.io.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ComplexityAnalysisESLintLauncher implements ComplexityAnalysis {
    private static final Logger LOGGER = LogManager.getLogger(ComplexityAnalysisESLintLauncher.class);

    private final Map<String, String> options = new HashMap<>();

    @Override
    public void addOption(String option, String value) {
        options.put(option, value);
    }

    @Override
    public void run(String instanceKey) {
        List<String> parameters = new ArrayList<>();

        ProcessBuilder process = new ProcessBuilder();

        if (!SystemUtils.IS_OS_WINDOWS) {
            parameters.add("/bin/sh");
            parameters.add("-c");
        }

        String eslintDir = saveESLintAndGetPath();
        LOGGER.debug("ESLint Dir. : {}", eslintDir);
        String eslint = eslintDir + File.separator + "node_modules" + File.separator + ".bin" + File.separator + "eslint";

        if (SystemUtils.IS_OS_WINDOWS) {
            eslint += ".cmd";
        } else {
            File esLintExecute = new File(eslint);
            esLintExecute.setExecutable(true);
        }

        try {
            LOGGER.info("ESLint 'complexity' rule checking...");
            String nodePath = NodeRuntime.findNodeRuntimePath(instanceKey);

            File workingDirectory = (new File(nodePath)).getParentFile();
            process.directory(workingDirectory);
            LOGGER.debug("Working directory : {}", workingDirectory);

            // eslint --no-eslintrc -c "D:\workspace for tools\code-analyst\src\main\resources\statics\nodejs\ESLint\complexity.eslintrc.json" -f json "D:\Repositories\BitBucket\eStore (Global)\address-adapter-lib" -o result.json --debug

            File rc = IOAndFileUtils.saveResourceFile("/statics/nodejs/ESLint/complexity.eslintrc.json", "eslint", ".json");

            File output = File.createTempFile("result-", ".json");

            List<String> subParameters = new ArrayList<>();
            subParameters.add(eslint);
            subParameters.add("--no-eslintrc");
            subParameters.add("-c");
            subParameters.add(rc.getPath());
            subParameters.add("-f");
            subParameters.add("json");
            subParameters.add("-o");
            subParameters.add(output.getPath());

            if (options.containsKey("-debug")) {
                subParameters.add("--debug");
            }

            // 여러 소스인 경우 경로들만 파라미터로 추가
            String[] srcPaths = options.get("-dir").split(FindFileUtils.COMMA_SPLITTER);
            //subParameters.addAll(Arrays.asList(srcPaths));
            for (String srcPath : srcPaths) {
                String path  = new File(srcPath).getAbsolutePath();
                LOGGER.info("src : " + path);
                subParameters.add(path);
            }

            if (SystemUtils.IS_OS_WINDOWS) {
                parameters.addAll(subParameters);
            } else {
                StringBuilder buffer = new StringBuilder();

                for (String param : subParameters) {
                    if (param.contains(" ")) {
                        buffer.append("\"").append(param).append("\"").append(" ");
                    } else {
                        buffer.append(param).append(" ");
                    }
                }

                parameters.add(buffer.toString().trim());
            }

            process.command(parameters.toArray(new String[0]));

            Map<String,String> env = process.environment();
            String path = env.get("PATH");
            path = path + File.pathSeparator + workingDirectory.getPath();
            env.put("PATH", path);

            Process eslintProcess = process.start();

            LOGGER.debug(parameters);

            int errCode = eslintProcess.waitFor();
            if (errCode != 0 && errCode != 1) { // return 1 if there are violations or too many warning...
                System.out.println("ESLint Error :");
                try (InputStream out = eslintProcess.getInputStream()) {
                    copy(out, System.out);
                }
                try (InputStream out = eslintProcess.getErrorStream()) {
                    copy(out, System.out);
                }
                throw new RuntimeException("ESLint error code : " + errCode);
            }

            List<ComplexityResult> list = parseResult(output.getPath(), MeasuredResult.getInstance(instanceKey).getProjectDirectory());

            MeasuredResult.getInstance(instanceKey).putComplexityList(list);

        } catch (NodeRuntimeException ex) {
            throw new RuntimeException(ex);
        } catch (IOException ex) {
            throw new UncheckedIOException(ex);
        } catch (InterruptedException ex) {
            throw new UncheckedExecutionException(ex);
        }
    }

    private String saveESLintAndGetPath() {
        File zipFile = IOAndFileUtils.saveResourceFile("/statics/nodejs/ESLint/ESLint.zip", "eslint", ".zip");

        File dir = Files.createTempDir();

        try {
            ZipUtils.unzip(zipFile, dir);
        } catch (IOException ex) {
            throw new UncheckedIOException(ex);
        }

        return dir.getPath();
    }

    private List<ComplexityResult> parseResult(String path, String projectDirectory) {
        List<ComplexityResult> returnList = new ArrayList<>();

        ESLintResultFile[] results;

        Gson gson = new Gson();
        try (Reader json = new FileReader(path)) {
            results = gson.fromJson(json, ESLintResultFile[].class);
        } catch (IOException ex) {
            throw new UncheckedIOException(ex);
        }

        for (ESLintResultFile result : results) {
            String filePath = result.getFilePath();

            filePath = MeasuredResult.getConvertedFilePath(filePath, projectDirectory);

            LOGGER.debug("file : {}", filePath);

            if (result.getMessages() == null) {
                continue;
            }
            for (ESLintResultMessages message : result.getMessages()) {
                if ("complexity".equals(message.getRuleId())) {

                    Pattern p = Pattern.compile("^(Function|Method|Generator function|Static method|Arrow function|Constructor) '(.+)' has a complexity of ([0-9]+)\\.$");
                    Matcher m = p.matcher(message.getMessage());

                    if (m.find()) {
                        int line = message.getLine();
                        String function = m.group(2);
                        int complexity = Integer.parseInt(m.group(3));

                        returnList.add(new ComplexityResult(filePath, line, function, complexity));
                    } else {
                        Pattern p2 = Pattern.compile("^(Function|Method|Generator function|Static method|Arrow function|Constructor) has a complexity of ([0-9]+)\\.$");
                        Matcher m2 = p2.matcher(message.getMessage());

                        if (m2.find()) {
                            int line = message.getLine();
                            String function = "<anonymous>";
                            int complexity = Integer.parseInt(m2.group(2));

                            returnList.add(new ComplexityResult(filePath, line, function, complexity));
                        } else {
                            Pattern p3 = Pattern.compile("^(.+) has a complexity of ([0-9]+)\\.$");
                            Matcher m3 = p3.matcher(message.getMessage());

                            if (m3.find()) {
                                int line = message.getLine();
                                String function = "<anonymous>";
                                int complexity = Integer.parseInt(m3.group(2));
                                LOGGER.warn("Complexity type not found : {}", m3.group(1));

                                returnList.add(new ComplexityResult(filePath, line, function, complexity));
                            } else {
                                throw new RuntimeException("ESLint message format error : " + message.getMessage());
                            }
                        }
                    }
                }
            }
        }

        return returnList;
    }

    private void copy(InputStream input, OutputStream output) throws IOException {
        byte[] buffer = new byte[1024];
        int n;
        while ((n = input.read(buffer)) != -1) {
            output.write(buffer, 0, n);
        }
    }
}
